# Этот документ содержит правила и рекомендации по написанию кода и комментариев для Go-бэкенда.

## Форматирование

---
- Исходные файлы должны быть отформатированы с помощью ```go fmt```
- Импорты группировать в следующем порядке:
  1. Стандартные библиотеки
  2. Внешние пакеты
  3. Внутренние пакеты проекта

---
## Именование

---
### Пакеты
* Имена пакетов должны быть короткими, строчными, без подчёркиваний и смешанного регистра
* Избегайте имён вроде utils, common, helpers — они слишком общие. Лучше назвать пакет по его функциональности.
### Переменные:
- Используйте camelCase для локальных переменных и полей структур  (экспортируемые поля — с большой буквы).

> lowerCamelCase - для локальных переменных
> ```userID, parseRequest, config, err```

>UpperCamelCase - для экспортируемых (публичных) элементов
>```GetUser, User, Config, ParseRequest.```

- Имена должны быть короткими, но осмысленными:
 >```i``` для счётчиков циклов
 >```r``` для HTTP-запроса
 >```w``` для HTTP-ответа
 >```cfg``` для конфигурации

- Для слайсов и мап старайтесь использовать множественное число: ```users, items```

### Функции
- Имена функций должны отражать их действие: ```GetUser, SaveOrder, ValidateEmail```
- Если функция возвращает bool, имя может начинаться с Is, Has, Can: 
  - ```Is``` – для состояний или свойств (IsValid, IsEmpty)
  - ```Has``` – для наличия чего-либо (HasChildren, HasError)
  - ```Can``` – для возможности выполнения действия (CanSend,  CanEdit)

- Экспортируемые функции должны иметь комментарии, описывающие их назначение.
- Неэкспортируемые функции — внутренние комментарии желательны

### Интерфейсы
- Имена интерфейсов, содержащих один метод, обычно образуются от названия метода с суффиксом er: ```Reader, Writer, Logger```
- Для интерфейсов с несколькими методами старайтесь дать осмысленное имя, отражающее их роль ```Storage, Notifier```

---

## Комментарии

---
### Язык комментариев
Все комментарии пишутся на русском языке

### Комментарии к экспортируемым элементам
Каждый экспортируемый элемент (переменная, константа, функция, метод, тип, структура, интерфейс) должен иметь комментарий, начинающийся с его имени.

~~~
// GetUser возвращает пользователя по его ID.
// Если пользователь не найден, возвращает ошибку ErrUserNotFound.
func GetUser(id int) (*User, error) 
~~~

* Комментарии к структурам описывают её назначение:

~~~
// User представляет данные пользователя в системе.
type User struct {
    ID   int
    Name string
}
~~~

### Внутренние комментарии
- Комментируйте сложные или неочевидные фрагменты кода, особенно если они содержат нетривиальную логику, оптимизации или обходные пути.
- Не комментируйте очевидные вещи (например, i++ // увеличиваем i).

### TODO и FIXME
Если оставляете незаконченную работу или знаете о проблеме, используйте комментарии TODO(username): ... или FIXME: ....

> Например: // TODO(ivan): заменить на нормальную валидацию после имплементации пакета validator.

---
## Обработка ошибок

---
- Всегда проверяйте ошибки. Никогда не игнорируйте их (даже если уверены, что ошибки не будет, лучше явно обработать).
- Используйте %w для оборачивания ошибок с помощью fmt.Errorf, чтобы сохранить контекст.
- Определяйте собственные типы ошибок или переменные-ошибки для специфичных ситуаций:
~~~
var ErrUserNotFound = errors.New("user not found")
~~~

- Для логирования используйте структурированный логгер (например, log/slog или сторонний). Пишите логи на английском.

---
## HTTP-обработчики

---
- Разделяйте маршрутизацию, middleware и обработчики.
- Обработчики должны быть тонкими: они принимают запрос, вызывают методы сервисного слоя, возвращают ответ (или ошибку).
- Используйте стандартный пакет net/http или легковесные фреймворки (например, gorilla/mux, chi).
- Возвращайте структурированные ответы в JSON.

---
## Middleware

---
* Пишите middleware как функции, принимающие http.Handler и возвращающие http.Handler.
* Каждый middleware должен выполнять одну задачу (логирование, аутентификация, паника-рековери).

~~~
func Logger(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {`
        log.Println("Before handler")
        next.ServeHTTP(w, r) // Вызов следующего обработчика
        log.Println("After handler")
    })
}
~~~

---
### Тестирование

---
* Называйте тестовые файлы _test.go.
* Имена тестовых функций должны начинаться с Test и описывать тестируемое поведение: ```TestGetUserSuccess, TestCreateUserDuplicateEmail```.
* Держите тесты независимыми и изолированными.


